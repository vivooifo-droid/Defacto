# Указатели в стиле Rust для Defacto

Прототип системы указателей для языка Defacto, вдохновлённый Rust, но адаптированный под синтаксис и философию языка.

## Концепция

Defacto — низкоуровневый язык для x86-32, поэтому указатели являются естественной частью языка. Однако, в отличие от C/C++, мы заимствуем идеи безопасности из Rust:

- **Явное владение** — указатель владеет памятью
- **Безопасное разыменование** — оператор `*` для доступа к значению
- **Ссылки** — заимствование без владения (`&`)
- **Null-безопасность** — опциональные указатели
- **Системный аллокатор** — malloc/free для динамической памяти

## Статус реализации

**v0.30+ с поддержкой аллокатора:**

- ✅ Компилятор модифицирован для поддержки `malloc/free`
- ✅ Парсинг указателей: `*i32`, `**i32`, `&var`, `*ptr`
- ✅ Генерация кода для выделения памяти
- ✅ Terminal mode с libc

## Синтаксис

### Объявление указателя

```de
var ptr: *i32           // указатель на i32
var ptr: *string        // указатель на строку
var ptr: **i32          // указатель на указатель
```

### Получение адреса (оператор `&`)

```de
var x: i32 = 42
var ptr: *i32 = &x      // ptr указывает на x
```

### Разыменование (оператор `*`)

```de
var value: i32 = *ptr   // прочитать значение по указателю
*ptr = 100              // записать значение по указателю
```

### Null-указатель

```de
var ptr: *i32 = null    // null-указатель
```

### Выделение памяти (alloc/dealloc)

```de
var ptr: *i32
var size: i32 = 4

static.pl>

// Выделить память (4 байта для i32)
alloc{size}             // malloc(size), результат в EAX

// Освободить память
dealloc{ptr}            // free(ptr)
```

### Указатели на структуры

```de
struct Point {
    x: i32
    y: i32
}

var p: Point
var ptr: *Point = &p

// Доступ к полям через указатель
(*ptr).x = 10           // явное разыменование
ptr->x = 20             // синтаксический сахар (как в Rust)
```

## Примеры использования

### 1. Базовое использование указателей

```de
var x: i32 = 10
var ptr: *i32 = &x
var y: i32 = *ptr       // y = 10
*ptr = 20               // x = 20
```

### 2. Указатели в функциях

```de
function == increment {
    <.de
        var ptr: *i32
        static.pl>
        *ptr = (*ptr + 1)
    .>
}

var x: i32 = 5
var ptr: *i32 = &x
#MOV {#R1, ptr}
call #increment
```

### 3. Связанные списки

```de
struct Node {
    data: i32
    next: *Node
}

var head: *Node = null
```

### 4. Массивы и указатели

```de
var arr: i32[10]
var ptr: *i32 = &arr[0]

// Арифметика указателей
ptr = (ptr + 1)         // следующий элемент
```

## Отличия от Rust

| Rust | Defacto | Примечание |
|------|---------|------------|
| `let x = 5;` | `var x: i32 = 5;` | Синтаксис объявлений |
| `let r = &x;` | `var r: *i32 = &x;` | Явный тип указателя |
| `*r` | `*r` | Разыменование одинаковое |
| `x.field` | `x.field` или `x->field` | Для указателей на структуры |
| Borrow checker | Нет | Упрощённая модель |

## Безопасность

В текущей реализации **безопасность обеспечивается программистом**:

- Нет borrow checker'а как в Rust
- Нет гарантий времени жизни
- Нет проверки на null при разыменовании

Это осознанное решение для низкоуровневого языка, где нужен полный контроль.

## Планы на будущее

- [ ] Опциональные указатели `?i32`
- [ ] Умные указатели (Box, Rc, Arc)
- [ ] Проверка границ для массивов
- [ ] Интеграция с автоматическим управлением памятью v0.30+

## Файлы в этом прототипе

```
pointers-prototype/
├── README.md              # Этот файл
├── docs/
│   └── syntax.md          # Полная документация по синтаксису
└── examples/
    ├── basic.de           # Базовые примеры
    ├── functions.de       # Указатели в функциях
    ├── structs.de         # Указатели на структуры
    ├── linked-list.de     # Связанный список
    └── arithmetics.de     # Арифметика указателей
```

## Статус

**Прототип!** Это дизайн-документ и примеры синтаксиса. Для полной поддержки требуется модификация компилятора (lexer.h, parser.h, codegen.h).
