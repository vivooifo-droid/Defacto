# Синтаксис указателей для Defacto

Полная спецификация синтаксиса указателей в стиле Rust для языка Defacto v0.30+.

## Оглавление

1. [Типы указателей](#типы-указателей)
2. [Операторы](#операторы)
3. [Объявление и инициализация](#объявление-и-инициализация)
4. [Указатели на структуры](#указатели-на-структуры)
5. [Арифметика указателей](#арифметика-указателей)
6. [Null-указатели](#null-указатели)
7. [Указатели в функциях](#указатели-в-функциях)
8. [Массивы и указатели](#массивы-и-указатели)
9. [Двойные указатели](#двойные-указатели)
10. [Системный аллокатор](#системный-аллокатор)
11. [Ограничения](#ограничения)

---

## Типы указателей

### Базовый синтаксис

```de
var ptr: *i32           // указатель на i32
var ptr: *i64           // указатель на i64
var ptr: *u8            // указатель на u8
var ptr: *string        // указатель на строку
var ptr: *pointer       // указатель на pointer
```

### Указатели на структуры

```de
struct Point {
    x: i32
    y: i32
}

var ptr: *Point         // указатель на Point
```

### Двойные указатели

```de
var ptr: **i32          // указатель на указатель на i32
var ptr: ***Point       // указатель на указатель на указатель на Point
```

---

## Операторы

### `&` — Взятие адреса

Возвращает адрес переменной в памяти.

```de
var x: i32 = 42
var ptr: *i32 = &x      // ptr содержит адрес x
```

**Правила:**
- Можно брать адрес только переменных (`var`), не `const`
- Адрес временных значений невозможен: `&42` — ошибка

### `*` — Разыменование

Доступ к значению по указателю.

```de
var x: i32 = 42
var ptr: *i32 = &x

var y: i32 = *ptr       // y = 42
*ptr = 100              // x = 100
```

**Правила:**
- Разыменование null-указателя — неопределённое поведение
- Двойное разыменование: `**ptr` для `**i32`

### `->` — Доступ к полю структуры

Синтаксический сахар для `(*ptr).field`.

```de
struct Point {
    x: i32
    y: i32
}

var p: Point
var ptr: *Point = &p

ptr->x = 10             // то же что: (*ptr).x = 10
ptr->y = 20
```

---

## Объявление и инициализация

### Объявление без инициализации

```de
var ptr: *i32           // неинициализированный указатель
```

⚠️ **Важно:** Использование неинициализированного указателя — ошибка.

### Объявление с инициализацией

```de
var x: i32 = 42
var ptr: *i32 = &x      // корректно
```

### Null-инициализация

```de
var ptr: *i32 = null    // безопасный null-указатель
```

---

## Указатели на структуры

### Определение структуры с указателями

```de
struct Node {
    data: i32
    next: *Node         // указатель на следующую ноду
}
```

### Доступ к полям

```de
struct Player {
    x: i32
    y: i32
    health: i32
}

var p: Player
var ptr: *Player = &p

// Способ 1: явное разыменование
(*ptr).x = 10

// Способ 2: синтаксический сахар (рекомендуется)
ptr->x = 10
```

### Вложенные структуры

```de
struct Point {
    x: i32
    y: i32
}

struct Player {
    pos: Point
    health: i32
}

var player: Player
var ptr: *Player = &player

ptr->pos.x = 100        // доступ к вложенному полю
ptr->pos.y = 200
```

---

## Арифметика указателей

### Сложение

```de
var arr: i32[10]
var ptr: *i32 = &arr[0]

ptr = (ptr + 1)         // сдвиг на 1 элемент (4 байта для i32)
```

### Вычитание

```de
var ptr1: *i32 = &arr[0]
var ptr2: *i32 = &arr[5]

var diff: i32 = (ptr2 - ptr1)   // diff = 5 (элементов)
```

### Сравнение

```de
if ptr1 == ptr2 {
    // указатели равны
}

if ptr1 != ptr2 {
    // указатели не равны
}
```

### Размер сдвига

| Тип | Размер сдвига |
|-----|---------------|
| `*i32` | 4 байта |
| `*i64` | 8 байт |
| `*u8` | 1 байт |
| `*string` | 4 байта |
| `*struct` | размер struct |

---

## Null-указатели

### Объявление

```de
var ptr: *i32 = null
```

### Проверка на null

```de
if ptr == null {
    display{"null pointer!"}
} else {
    display{*ptr}
}
```

### Безопасное разыменование

```de
if ptr != null {
    var x: i32 = *ptr
}
```

---

## Указатели в функциях

### Передача по указателю

```de
function == increment {
    <.de
        var ptr: *i32
        static.pl>
        *ptr = (*ptr + 1)
    .>
}

var x: i32 = 5
var ptr: *i32 = &x
#MOV {#R1, ptr}
call #increment           // x = 6
```

### Возврат указателя (через параметр)

```de
function == get_pointer {
    <.de
        var out: **i32
        static.pl>
        // В реальной реализации:
        // *out = &some_value
    .>
}
```

### Изменение указателя через двойной указатель

```de
function == redirect {
    <.de
        var ptr: **i32
        var target: *i32
        static.pl>
        *ptr = target       // изменяем указатель, на который указывает ptr
    .>
}
```

---

## Массивы и указатели

### Имя массива как указатель

```de
var arr: i32[10]
var ptr: *i32 = &arr[0]   // указатель на первый элемент
```

### Доступ через индексацию указателя

```de
var arr: i32[10]
var ptr: *i32 = &arr[0]

// Эквивалентные записи:
var x: i32 = arr[0]
var x: i32 = *ptr
```

### Проход по массиву

```de
var arr: i32[10]
var ptr: *i32 = &arr[0]
var i: i32 = 0

loop {
    if i == 10 { stop }
    *ptr = (i * 10)
    ptr = (ptr + 1)
    i = (i + 1)
}
```

---

## Двойные указатели

### Объявление

```de
var x: i32 = 42
var ptr1: *i32 = &x
var ptr2: **i32 = &ptr1
```

### Разыменование

```de
var value: i32 = **ptr2     // value = 42
**ptr2 = 100                // x = 100
```

### Изменение указателя через двойной указатель

```de
function == redirect {
    <.de
        var ptr: **i32
        var target: *i32
        static.pl>
        *ptr = target       // изменяем указатель, на который указывает ptr
    .>
}
```

---

## Системный аллокатор

### Выделение памяти (malloc)

```de
var ptr: *i32
var size: i32 = 4

static.pl>

// Выделить память через malloc
alloc{size}             // malloc(size), результат в EAX
#MOV {ptr, #R1}         // сохранить указатель в переменную
```

### Освобождение памяти (free)

```de
dealloc{ptr}            // free(ptr)
```

### Пример: динамическое выделение

```de
<.de
    var ptr: *i32
    var size: i32 = 4
    static.pl>
    
    // Выделить память
    alloc{4}
    #MOV {ptr, #R1}
    
    // Записать значение
    #MOV {#R1, 100}
    #MOV {#R2, ptr}
    #MOV {[*R2], #R1}   // *ptr = 100
    
    // Освободить память
    dealloc{ptr}
.>
```

---

## Ограничения

### Поддерживается ✅

- [x] Базовые указатели `*T`
- [x] Двойные указатели `**T`
- [x] Оператор `&` (взятие адреса)
- [x] Оператор `*` (разыменование)
- [x] Оператор `->` (доступ к полю)
- [x] Null-указатели
- [x] Арифметика указателей (+, -)
- [x] Сравнение указателей (==)
- [x] Указатели на структуры
- [x] Указатели в функциях
- [x] Системный аллокатор (malloc/free)

### Не поддерживается ❌

- [ ] Borrow checker (как в Rust)
- [ ] Время жизни (lifetimes)
- [ ] Умные указатели (Box, Rc, Arc)
- [ ] Срезы (slices) `&[T]`
- [ ] Опциональные указатели `Option<*T>`
- [ ] Методы для указателей
- [ ] Приведение типов указателей

### Неопределённое поведение

⚠️ Следующие операции приводят к неопределённому поведению:

- Разыменование null-указателя
- Разыменование неинициализированного указателя
- Выход за границы массива
- Использование указателя после освобождения памяти
- Доступ к памяти другого типа (type punning)

---

## Примеры

### Hello World с указателями

```de
#Mainprogramm.start
#NO_RUNTIME
#SAFE

<.de
    var msg: string = "Hello, Pointers!"
    var ptr: *string = &msg
    static.pl>
    display{*ptr}
.>

#Mainprogramm.end
```

### Swap через указатели

```de
#Mainprogramm.start
#NO_RUNTIME
#SAFE

function == swap {
    <.de
        var a: *i32
        var b: *i32
        var temp: i32 = 0
        static.pl>
        temp = *a
        *a = *b
        *b = temp
    .>
}

<.de
    var x: i32 = 5
    var y: i32 = 10
    var px: *i32 = &x
    var py: *i32 = &y
    static.pl>
    
    #MOV {#R1, px}
    #MOV {#R2, py}
    call #swap
    
    display{x}      // 10
    display{y}      // 5
.>

#Mainprogramm.end
```

---

## Интеграция с компилятором

### Модифицированные файлы

- **lexer.h** — токены `AMP`, `STAR`, `TOK_NULL`, `ALLOC`, `DEALLOC`
- **parser.h** — парсинг `*Type`, `&var`, `*ptr`, `alloc{}`, `dealloc{}`
- **codegen.h** — генерация `malloc/free`, адресная арифметика
- **defacto.h** — узлы AST: `PtrAddrNode`, `PtrDerefNode`, `AllocNode`, `DeallocNode`

### Компиляция с аллокатором

```bash
# Terminal mode с поддержкой malloc/free
./defacto -terminal program.de

# Ссылка с libc
ld -m elf_i386 -o program program.o -lc
```

---

## Ссылки

- [README.md](../README.md) — Общая концепция
- [examples/](../examples/) — Примеры кода
- [Defacto Syntax](../../SYNTAX.md) — Базовый синтаксис Defacto
