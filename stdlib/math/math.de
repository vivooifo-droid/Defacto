// Defacto Standard Library - Math Module
// Complete mathematical functions

#Mainprogramm.start
#NO_RUNTIME
#SAFE

// ============ Basic Functions ============

// Absolute value
fn abs(x: i32) -> i32 {
    <.de
        var result: i32 = 0
        if x < 0 {
            result = (0 - x)
        } else {
            result = x
        }
    .>
}

// Minimum of two values
fn min(a: i32, b: i32) -> i32 {
    <.de
        var result: i32 = 0
        if a < b {
            result = a
        } else {
            result = b
        }
    .>
}

// Maximum of two values
fn max(a: i32, b: i32) -> i32 {
    <.de
        var result: i32 = 0
        if a > b {
            result = a
        } else {
            result = b
        }
    .>
}

// Clamp value between min and max
fn clamp(value: i32, min_val: i32, max_val: i32) -> i32 {
    <.de
        var result: i32 = 0
        if value < min_val {
            result = min_val
        } else if value > max_val {
            result = max_val
        } else {
            result = value
        }
    .>
}

// ============ Power Functions ============

// Power (x^n) - integer exponent
fn pow(base: i32, exp: i32) -> i32 {
    <.de
        var result: i32 = 1
        var i: i32 = 0
        var e: i32 = 0
        
        if exp < 0 {
            result = 0  // Integer division, can't handle negative exp
        } else if exp == 0 {
            result = 1
        } else {
            e = exp
            for i = 0 to e {
                result = (result * base)
            }
        }
    .>
}

// Square
fn sqr(x: i32) -> i32 {
    <.de
        var result: i32 = 0
        result = (x * x)
    .>
}

// Cube
fn cube(x: i32) -> i32 {
    <.de
        var result: i32 = 0
        result = (x * x * x)
    .>
}

// ============ Root Functions ============

// Square root (integer)
fn sqrt(x: i32) -> i32 {
    <.de
        var result: i32 = 0
        var i: i32 = 0
        
        if x <= 0 {
            result = 0
        } else if x == 1 {
            result = 1
        } else {
            for i = 1 to x {
                if (i * i) > x {
                    result = (i - 1)
                    stop
                }
            }
            result = x
        }
    .>
}

// ============ Arithmetic Functions ============

// Modulo (remainder)
fn mod(a: i32, b: i32) -> i32 {
    <.de
        var result: i32 = 0
        var temp: i32 = 0
        
        if b == 0 {
            result = 0  // Error case
        } else {
            temp = a
            while temp >= b {
                temp = (temp - b)
            }
            result = temp
        }
    .>
}

// Divide with rounding
fn div_round(a: i32, b: i32) -> i32 {
    <.de
        var result: i32 = 0
        // Simple integer division for now
        result = (a / b)
    .>
}

// ============ Bitwise Functions ============

// Check if bit is set
fn is_bit_set(value: i32, bit: i32) -> bool {
    <.de
        var result: bool = false
        var mask: i32 = 0
        mask = (1 << bit)
        if (value & mask) != 0 {
            result = true
        }
    .>
}

// Set bit
fn set_bit(value: i32, bit: i32) -> i32 {
    <.de
        var result: i32 = 0
        var mask: i32 = 0
        mask = (1 << bit)
        result = (value | mask)
    .>
}

// Clear bit
fn clear_bit(value: i32, bit: i32) -> i32 {
    <.de
        var result: i32 = 0
        var mask: i32 = 0
        mask = (1 << bit)
        mask = (mask ^ -1)  // Invert mask
        result = (value & mask)
    .>
}

// Toggle bit
fn toggle_bit(value: i32, bit: i32) -> i32 {
    <.de
        var result: i32 = 0
        var mask: i32 = 0
        mask = (1 << bit)
        result = (value ^ mask)
    .>
}

// ============ Sign Functions ============

// Check if positive
fn is_positive(x: i32) -> bool {
    <.de
        var result: bool = false
        if x > 0 {
            result = true
        }
    .>
}

// Check if negative
fn is_negative(x: i32) -> bool {
    <.de
        var result: bool = false
        if x < 0 {
            result = true
        }
    .>
}

// Sign function: -1, 0, or 1
fn sign(x: i32) -> i32 {
    <.de
        var result: i32 = 0
        if x < 0 {
            result = -1
        } else if x > 0 {
            result = 1
        } else {
            result = 0
        }
    .>
}

// ============ Comparison Functions ============

// Check if in range
fn in_range(value: i32, min_val: i32, max_val: i32) -> bool {
    <.de
        var result: bool = false
        if value >= min_val && value <= max_val {
            result = true
        }
    .>
}

#Mainprogramm.end
